// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title IdentityRegistry
 * @dev Handles decentralized identity registration and updates on Moca Chain
 */
contract IdentityRegistry is Ownable, ReentrancyGuard {
    struct Identity {
        string didURI;
        uint256 createdAt;
        uint256 updatedAt;
        bool exists;
    }

    mapping(address => Identity) private identities;
    mapping(string => address) private didToAddress;
    
    address[] public registeredUsers;
    uint256 public totalIdentities;

    event IdentityRegistered(address indexed user, string didURI, uint256 timestamp);
    event IdentityUpdated(address indexed user, string oldDIDURI, string newDIDURI, uint256 timestamp);
    event IdentityRevoked(address indexed user, string didURI, uint256 timestamp);

    modifier onlyIdentityOwner(address user) {
        require(msg.sender == user || msg.sender == owner(), "Not authorized");
        _;
    }

    modifier identityExists(address user) {
        require(identities[user].exists, "Identity does not exist");
        _;
    }

    constructor(address initialOwner) Ownable(initialOwner) {
        // Initialize the contract with the initial owner
    }

    /**
     * @dev Register a new decentralized identity
     * @param user The address to register the identity for
     * @param didURI The DID URI generated by AIR Kit
     */
    function registerIdentity(address user, string memory didURI) 
        public 
        nonReentrant 
        onlyIdentityOwner(user) 
    {
        require(!identities[user].exists, "Identity already exists");
        require(bytes(didURI).length > 0, "DID URI cannot be empty");
        require(didToAddress[didURI] == address(0), "DID URI already registered");

        identities[user] = Identity({
            didURI: didURI,
            createdAt: block.timestamp,
            updatedAt: block.timestamp,
            exists: true
        });

        didToAddress[didURI] = user;
        registeredUsers.push(user);
        totalIdentities++;

        emit IdentityRegistered(user, didURI, block.timestamp);
    }

    /**
     * @dev Update an existing identity's DID URI
     * @param user The address of the identity owner
     * @param newDIDURI The new DID URI
     */
    function updateIdentity(address user, string memory newDIDURI) 
        public 
        nonReentrant 
        onlyIdentityOwner(user) 
        identityExists(user) 
    {
        require(bytes(newDIDURI).length > 0, "New DID URI cannot be empty");
        require(didToAddress[newDIDURI] == address(0), "New DID URI already registered");

        string memory oldDIDURI = identities[user].didURI;
        
        // Remove old DID mapping
        delete didToAddress[oldDIDURI];
        
        // Update identity
        identities[user].didURI = newDIDURI;
        identities[user].updatedAt = block.timestamp;
        
        // Add new DID mapping
        didToAddress[newDIDURI] = user;

        emit IdentityUpdated(user, oldDIDURI, newDIDURI, block.timestamp);
    }

    /**
     * @dev Revoke an identity (emergency function)
     * @param user The address of the identity to revoke
     */
    function revokeIdentity(address user) 
        public 
        onlyOwner 
        identityExists(user) 
    {
        string memory didURI = identities[user].didURI;
        
        delete didToAddress[didURI];
        delete identities[user];
        totalIdentities--;

        emit IdentityRevoked(user, didURI, block.timestamp);
    }

    /**
     * @dev Get identity information for a user
     * @param user The address to query
     * @return didURI The DID URI
     * @return createdAt Creation timestamp
     * @return updatedAt Last update timestamp
     */
    function getIdentity(address user) 
        public 
        view 
        returns (string memory didURI, uint256 createdAt, uint256 updatedAt) 
    {
        require(identities[user].exists, "Identity does not exist");
        Identity memory identity = identities[user];
        return (identity.didURI, identity.createdAt, identity.updatedAt);
    }

    /**
     * @dev Get address from DID URI
     * @param didURI The DID URI to query
     * @return The address associated with the DID
     */
    function getAddressFromDID(string memory didURI) 
        public 
        view 
        returns (address) 
    {
        return didToAddress[didURI];
    }

    /**
     * @dev Check if an identity exists
     * @param user The address to check
     * @return True if identity exists
     */
    function hasIdentity(address user) public view returns (bool) {
        return identities[user].exists;
    }

    /**
     * @dev Get all registered users (paginated)
     * @param offset Starting index
     * @param limit Maximum number of results
     * @return users Array of user addresses
     */
    function getRegisteredUsers(uint256 offset, uint256 limit) 
        public 
        view 
        returns (address[] memory users) 
    {
        require(offset < registeredUsers.length, "Offset out of bounds");
        
        uint256 end = offset + limit;
        if (end > registeredUsers.length) {
            end = registeredUsers.length;
        }
        
        users = new address[](end - offset);
        for (uint256 i = offset; i < end; i++) {
            users[i - offset] = registeredUsers[i];
        }
        
        return users;
    }
}